# Excel处理器系统 - 技术实现指南

## 🎯 实现优先级和策略

### 第一阶段：用户认证系统 (最高优先级)

#### 1.1 登录验证实现
**文件**: `ExcelProcessor.WPF/Windows/LoginWindow.xaml.cs`

```csharp
// 在LoginButton_Click方法中实现
private async void LoginButton_Click(object sender, RoutedEventArgs e)
{
    try
    {
        // 1. 输入验证
        if (string.IsNullOrEmpty(UsernameTextBox.Text) || string.IsNullOrEmpty(PasswordBox.Password))
        {
            MessageBox.Show("用户名和密码不能为空", "登录失败", MessageBoxButton.OK, MessageBoxImage.Warning);
            return;
        }

        // 2. 调用认证服务
        var authService = ServiceLocator.GetService<IAuthService>();
        var result = await authService.AuthenticateAsync(UsernameTextBox.Text, PasswordBox.Password);

        if (result.IsSuccess)
        {
            // 3. 保存用户会话
            Application.Current.Properties["CurrentUser"] = result.User;
            Application.Current.Properties["UserPermissions"] = result.Permissions;

            // 4. 打开主窗口
            var mainWindow = new MainWindow();
            mainWindow.Show();
            this.Close();
        }
        else
        {
            MessageBox.Show(result.ErrorMessage, "登录失败", MessageBoxButton.OK, MessageBoxImage.Error);
        }
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "登录过程中发生错误");
        MessageBox.Show("登录过程中发生错误，请稍后重试", "错误", MessageBoxButton.OK, MessageBoxImage.Error);
    }
}
```

#### 1.2 权限检查实现
**文件**: `ExcelProcessor.Data/Services/AuthService.cs`

```csharp
public async Task<AuthResult> CheckPermissionAsync(string username, string permission)
{
    try
    {
        // 1. 从数据库获取用户权限
        var user = await _userRepository.GetByUsernameAsync(username);
        if (user == null)
            return new AuthResult { IsSuccess = false, ErrorMessage = "用户不存在" };

        // 2. 获取用户角色权限
        var userPermissions = await _permissionRepository.GetUserPermissionsAsync(user.Id);
        
        // 3. 检查权限
        var hasPermission = userPermissions.Any(p => p.PermissionName == permission);
        
        return new AuthResult 
        { 
            IsSuccess = hasPermission, 
            ErrorMessage = hasPermission ? null : "权限不足" 
        };
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, $"检查用户 {username} 权限 {permission} 时发生错误");
        return new AuthResult { IsSuccess = false, ErrorMessage = "权限检查失败" };
    }
}
```

### 第二阶段：Excel配置管理 (核心业务功能)

#### 2.1 Excel配置CRUD实现
**文件**: `ExcelProcessor.Data/Services/ExcelService.cs`

```csharp
public async Task<ExcelConfig> CreateExcelConfigAsync(ExcelConfig config)
{
    try
    {
        // 1. 验证配置
        if (string.IsNullOrEmpty(config.ConfigName))
            throw new ArgumentException("配置名称不能为空");

        if (string.IsNullOrEmpty(config.FilePath))
            throw new ArgumentException("文件路径不能为空");

        // 2. 验证文件是否存在
        if (!File.Exists(config.FilePath))
            throw new FileNotFoundException($"Excel文件不存在: {config.FilePath}");

        // 3. 验证Excel文件格式
        await ValidateExcelFileAsync(config.FilePath);

        // 4. 保存到数据库
        config.CreatedAt = DateTime.Now;
        config.UpdatedAt = DateTime.Now;
        
        var savedConfig = await _excelConfigRepository.CreateAsync(config);
        
        _logger.LogInformation($"创建Excel配置成功: {config.ConfigName}, ID: {savedConfig.Id}");
        return savedConfig;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, $"创建Excel配置失败: {config.ConfigName}");
        throw;
    }
}

public async Task<ExcelConfig> GetExcelConfigAsync(int id)
{
    try
    {
        var config = await _excelConfigRepository.GetByIdAsync(id);
        if (config == null)
        {
            _logger.LogWarning($"Excel配置不存在: ID={id}");
            return null;
        }

        return config;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, $"获取Excel配置失败: ID={id}");
        throw;
    }
}

public async Task<IEnumerable<ExcelConfig>> GetAllExcelConfigsAsync()
{
    try
    {
        var configs = await _excelConfigRepository.GetAllAsync();
        _logger.LogInformation($"获取所有Excel配置成功，共 {configs.Count()} 个");
        return configs;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "获取所有Excel配置失败");
        throw;
    }
}
```

#### 2.2 Excel文件处理实现

```csharp
private async Task ValidateExcelFileAsync(string filePath)
{
    try
    {
        using (var package = new ExcelPackage(new FileInfo(filePath)))
        {
            var worksheet = package.Workbook.Worksheets.FirstOrDefault();
            if (worksheet == null)
                throw new InvalidOperationException("Excel文件中没有工作表");

            // 检查是否有数据
            var hasData = worksheet.Cells.Value != null;
            if (!hasData)
                throw new InvalidOperationException("Excel文件中没有数据");
        }
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, $"验证Excel文件失败: {filePath}");
        throw new InvalidOperationException($"Excel文件验证失败: {ex.Message}");
    }
}

public async Task<ExcelImportResult> ImportExcelDataAsync(int configId, string filePath)
{
    try
    {
        var config = await GetExcelConfigAsync(configId);
        if (config == null)
            throw new ArgumentException($"配置不存在: ID={configId}");

        var result = new ExcelImportResult
        {
            ConfigId = configId,
            FilePath = filePath,
            StartTime = DateTime.Now
        };

        using (var package = new ExcelPackage(new FileInfo(filePath)))
        {
            var worksheet = package.Workbook.Worksheets.FirstOrDefault();
            if (worksheet == null)
                throw new InvalidOperationException("Excel文件中没有工作表");

            // 读取数据
            var dataTable = new DataTable();
            var range = worksheet.Cells[worksheet.Dimension.Start.Row, worksheet.Dimension.Start.Column, 
                                      worksheet.Dimension.End.Row, worksheet.Dimension.End.Column];
            
            // 添加列
            for (int col = 1; col <= range.Columns; col++)
            {
                var header = worksheet.Cells[1, col].Value?.ToString() ?? $"Column{col}";
                dataTable.Columns.Add(header);
            }

            // 添加数据行
            for (int row = 2; row <= range.Rows; row++)
            {
                var dataRow = dataTable.NewRow();
                for (int col = 1; col <= range.Columns; col++)
                {
                    dataRow[col - 1] = worksheet.Cells[row, col].Value?.ToString() ?? "";
                }
                dataTable.Rows.Add(dataRow);
            }

            // 导入到数据库
            await ImportDataToDatabaseAsync(config, dataTable);
            
            result.TotalRows = dataTable.Rows.Count;
            result.SuccessRows = dataTable.Rows.Count;
            result.EndTime = DateTime.Now;
            result.IsSuccess = true;
        }

        _logger.LogInformation($"Excel数据导入成功: 配置ID={configId}, 行数={result.TotalRows}");
        return result;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, $"Excel数据导入失败: 配置ID={configId}");
        throw;
    }
}
```

### 第三阶段：作业调度系统

#### 3.1 调度器控制实现
**文件**: `ExcelProcessor.Data/Services/JobService.cs`

```csharp
private IScheduler _scheduler;

public async Task<(bool success, string message)> StartSchedulerAsync()
{
    try
    {
        if (_scheduler != null && !_scheduler.IsShutdown)
        {
            return (false, "调度器已经在运行");
        }

        // 创建调度器
        var props = new NameValueCollection
        {
            { "quartz.serializer.type", "binary" }
        };
        
        var factory = new StdSchedulerFactory(props);
        _scheduler = await factory.GetScheduler();
        
        // 启动调度器
        await _scheduler.Start();
        
        _logger.LogInformation("作业调度器启动成功");
        return (true, "作业调度器启动成功");
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "启动作业调度器失败");
        return (false, $"启动作业调度器失败: {ex.Message}");
    }
}

public async Task<(bool success, string message)> StopSchedulerAsync()
{
    try
    {
        if (_scheduler == null || _scheduler.IsShutdown)
        {
            return (false, "调度器未运行");
        }

        await _scheduler.Shutdown(true);
        _scheduler = null;
        
        _logger.LogInformation("作业调度器停止成功");
        return (true, "作业调度器停止成功");
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "停止作业调度器失败");
        return (false, $"停止作业调度器失败: {ex.Message}");
    }
}

public async Task<(bool isRunning, bool isPaused, DateTime? lastRunTime)> GetSchedulerStatusAsync()
{
    try
    {
        if (_scheduler == null)
            return (false, false, null);

        var isRunning = !_scheduler.IsShutdown;
        var isPaused = _scheduler.IsStarted && _scheduler.InStandbyMode;
        
        // 获取最后运行时间
        var jobKeys = await _scheduler.GetJobKeys(GroupMatcher<JobKey>.AnyGroup());
        DateTime? lastRunTime = null;
        
        foreach (var jobKey in jobKeys)
        {
            var triggers = await _scheduler.GetTriggersOfJob(jobKey);
            foreach (var trigger in triggers)
            {
                var previousFireTime = trigger.GetPreviousFireTimeUtc();
                if (previousFireTime.HasValue && 
                    (!lastRunTime.HasValue || previousFireTime.Value.DateTime > lastRunTime.Value))
                {
                    lastRunTime = previousFireTime.Value.DateTime;
                }
            }
        }

        return (isRunning, isPaused, lastRunTime);
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "获取调度器状态失败");
        throw;
    }
}
```

#### 3.2 定时作业管理实现

```csharp
public async Task<(bool success, string message)> AddScheduledJobAsync(string jobId, string cronExpression)
{
    try
    {
        if (_scheduler == null || _scheduler.IsShutdown)
        {
            return (false, "调度器未运行");
        }

        // 验证Cron表达式
        if (!CronExpression.IsValidExpression(cronExpression))
        {
            return (false, "无效的Cron表达式");
        }

        // 创建作业
        var job = JobBuilder.Create<ExcelImportJob>()
            .WithIdentity(jobId, "ExcelImportGroup")
            .UsingJobData("jobId", jobId)
            .Build();

        // 创建触发器
        var trigger = TriggerBuilder.Create()
            .WithIdentity($"{jobId}_trigger", "ExcelImportGroup")
            .WithCronSchedule(cronExpression)
            .Build();

        // 添加作业到调度器
        await _scheduler.ScheduleJob(job, trigger);
        
        _logger.LogInformation($"添加定时作业成功: {jobId}, Cron: {cronExpression}");
        return (true, "定时作业添加成功");
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "添加定时作业失败: {JobId}", jobId);
        return (false, $"添加定时作业失败: {ex.Message}");
    }
}

public async Task<List<(string jobId, string cronExpression, DateTime? nextRunTime)>> GetScheduledJobsAsync()
{
    try
    {
        if (_scheduler == null || _scheduler.IsShutdown)
            return new List<(string jobId, string cronExpression, DateTime? nextRunTime)>();

        var result = new List<(string jobId, string cronExpression, DateTime? nextRunTime)>();
        var jobKeys = await _scheduler.GetJobKeys(GroupMatcher<JobKey>.AnyGroup());

        foreach (var jobKey in jobKeys)
        {
            var triggers = await _scheduler.GetTriggersOfJob(jobKey);
            foreach (var trigger in triggers)
            {
                var cronTrigger = trigger as ICronTrigger;
                if (cronTrigger != null)
                {
                    var nextRunTime = trigger.GetNextFireTimeUtc()?.DateTime;
                    result.Add((jobKey.Name, cronTrigger.CronExpressionString, nextRunTime));
                }
            }
        }

        return result;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "获取定时作业列表失败");
        throw;
    }
}
```

### 第四阶段：系统设置功能

#### 4.1 数据库管理实现
**文件**: `ExcelProcessor.WPF/Pages/SystemSettingsPage.xaml.cs`

```csharp
public async Task<(bool success, string message)> TestDatabaseConnectionAsync()
{
    try
    {
        var connectionString = GetCurrentConnectionString();
        using (var connection = new SqlConnection(connectionString))
        {
            await connection.OpenAsync();
            
            // 测试基本查询
            using (var command = new SqlCommand("SELECT 1", connection))
            {
                await command.ExecuteScalarAsync();
            }
        }

        return (true, "数据库连接测试成功");
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "数据库连接测试失败");
        return (false, $"数据库连接测试失败: {ex.Message}");
    }
}

public async Task<(bool success, string message)> BackupDatabaseAsync()
{
    try
    {
        var connectionString = GetCurrentConnectionString();
        var backupPath = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.Desktop),
            $"ExcelProcessor_Backup_{DateTime.Now:yyyyMMdd_HHmmss}.bak"
        );

        using (var connection = new SqlConnection(connectionString))
        {
            await connection.OpenAsync();
            
            var backupQuery = $@"
                BACKUP DATABASE [{connection.Database}] 
                TO DISK = '{backupPath}' 
                WITH FORMAT, INIT, NAME = 'ExcelProcessor-Full Database Backup', 
                SKIP, NOREWIND, NOUNLOAD, STATS = 10";

            using (var command = new SqlCommand(backupQuery, connection))
            {
                await command.ExecuteNonQueryAsync();
            }
        }

        return (true, $"数据库备份成功: {backupPath}");
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "数据库备份失败");
        return (false, $"数据库备份失败: {ex.Message}");
    }
}
```

#### 4.2 设置管理实现

```csharp
public async Task<(bool success, string message)> ExportSettingsAsync()
{
    try
    {
        var settings = new SystemSettings
        {
            DatabaseConnectionString = GetCurrentConnectionString(),
            LogLevel = GetCurrentLogLevel(),
            AutoBackupEnabled = GetAutoBackupSetting(),
            // 其他设置...
        };

        var settingsPath = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.Desktop),
            $"ExcelProcessor_Settings_{DateTime.Now:yyyyMMdd_HHmmss}.json"
        );

        var json = JsonSerializer.Serialize(settings, new JsonSerializerOptions 
        { 
            WriteIndented = true 
        });
        await File.WriteAllTextAsync(settingsPath, json);

        return (true, $"设置导出成功: {settingsPath}");
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "设置导出失败");
        return (false, $"设置导出失败: {ex.Message}");
    }
}

public async Task<(bool success, string message)> ImportSettingsAsync(string filePath)
{
    try
    {
        if (!File.Exists(filePath))
            return (false, "设置文件不存在");

        var json = await File.ReadAllTextAsync(filePath);
        var settings = JsonSerializer.Deserialize<SystemSettings>(json);

        // 验证设置
        if (settings == null)
            return (false, "设置文件格式无效");

        // 应用设置
        await ApplySettingsAsync(settings);

        return (true, "设置导入成功");
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "设置导入失败");
        return (false, $"设置导入失败: {ex.Message}");
    }
}
```

## 🛠️ 技术要点和最佳实践

### 1. 异常处理
```csharp
// 统一异常处理模式
try
{
    // 业务逻辑
    var result = await ProcessDataAsync();
    return new ServiceResult { IsSuccess = true, Data = result };
}
catch (ValidationException ex)
{
    _logger.LogWarning(ex, "数据验证失败");
    return new ServiceResult { IsSuccess = false, ErrorMessage = ex.Message };
}
catch (Exception ex)
{
    _logger.LogError(ex, "处理数据时发生未预期错误");
    return new ServiceResult { IsSuccess = false, ErrorMessage = "系统内部错误" };
}
```

### 2. 日志记录
```csharp
// 结构化日志记录
_logger.LogInformation("开始处理Excel文件: {FilePath}, 配置ID: {ConfigId}", filePath, configId);

// 性能日志
using var scope = _logger.BeginScope("Excel导入操作");
var stopwatch = Stopwatch.StartNew();

// 业务逻辑...

stopwatch.Stop();
_logger.LogInformation("Excel导入完成，耗时: {ElapsedMs}ms, 处理行数: {RowCount}", 
    stopwatch.ElapsedMilliseconds, rowCount);
```

### 3. 数据验证
```csharp
// 输入验证
public async Task<ValidationResult> ValidateExcelConfigAsync(ExcelConfig config)
{
    var errors = new List<string>();

    if (string.IsNullOrEmpty(config.ConfigName))
        errors.Add("配置名称不能为空");

    if (string.IsNullOrEmpty(config.FilePath))
        errors.Add("文件路径不能为空");

    if (!File.Exists(config.FilePath))
        errors.Add("指定的文件不存在");

    if (config.FieldMappings == null || !config.FieldMappings.Any())
        errors.Add("至少需要配置一个字段映射");

    return new ValidationResult 
    { 
        IsValid = !errors.Any(), 
        Errors = errors 
    };
}
```

### 4. 性能优化
```csharp
// 批量处理
public async Task ImportDataBatchAsync(DataTable dataTable, int batchSize = 1000)
{
    for (int i = 0; i < dataTable.Rows.Count; i += batchSize)
    {
        var batch = dataTable.AsEnumerable()
            .Skip(i)
            .Take(batchSize)
            .CopyToDataTable();

        await ProcessBatchAsync(batch);
        
        // 报告进度
        var progress = (double)i / dataTable.Rows.Count * 100;
        ReportProgress(progress);
    }
}
```

## 通用功能：编辑工作流（页面/对话框）

### 目标
统一“新增/编辑/保存/验证/提交/反馈”的页面级编辑流程，减少重复代码并提升一致性。

### 通用步骤
1. 收集表单数据（绑定 ViewModel）
2. 校验必填与合法性（本地校验 + 服务端校验）
3. 组织提交模型（Models）
4. 调用对应服务（Data 或 Core 层）
5. 显示结果反馈（成功/失败/错误详情）
6. 刷新列表或关闭对话框

### 通用代码入口
- 数据源：`IDataSourceService`
- SQL：`ISqlService`（配置CRUD）、`ISqlOutputService`（执行输出）
- Excel：`IExcelService`
- 表信息：`IDatabaseTableService`

### 校验建议
- 使用集中校验方法，封装为 `bool ValidateXxx(Model, out string error)`
- 统一返回友好错误消息，便于 UI 复用

### 反馈建议
- 成功统一使用 `SuccessDialog`
- 长耗时操作使用 `ProgressDialog` + `ISqlProgressCallback`（或类似进度回调）

### 复用示例
- 在SQL管理页重用 `ISqlOutputService` 完成“执行并输出到表/Excel”，其他页面可直接调用以避免重复实现。

## 📋 测试建议

### 1. 单元测试示例
```csharp
[Test]
public async Task CreateExcelConfig_WithValidData_ShouldSucceed()
{
    // Arrange
    var config = new ExcelConfig
    {
        ConfigName = "测试配置",
        FilePath = "test.xlsx",
        FieldMappings = new List<FieldMapping>()
    };

    // Act
    var result = await _excelService.CreateExcelConfigAsync(config);

    // Assert
    Assert.IsNotNull(result);
    Assert.AreEqual("测试配置", result.ConfigName);
    Assert.Greater(result.Id, 0);
}
```

### 2. 集成测试示例
```csharp
[Test]
public async Task ExcelImport_WithValidFile_ShouldImportData()
{
    // Arrange
    var config = await CreateTestConfigAsync();
    var filePath = CreateTestExcelFileAsync();

    // Act
    var result = await _excelService.ImportExcelDataAsync(config.Id, filePath);

    // Assert
    Assert.IsTrue(result.IsSuccess);
    Assert.Greater(result.TotalRows, 0);
    Assert.AreEqual(result.TotalRows, result.SuccessRows);
}
```

---

**文档版本**: 1.0  
**最后更新**: 2024年12月  
**维护人员**: 开发团队 