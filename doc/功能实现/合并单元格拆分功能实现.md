# 合并单元格拆分功能实现

## 功能概述

根据用户的需求，实现了真正的合并单元格拆分功能。这个功能将合并单元格的内容拆分显示在每个单独的单元格中，而不是将包含分隔符的单元格拆分成多行。

## 实现原理

### 1. 合并单元格检测

使用EPPlus库的 `MergedCells` 属性来检测Excel文件中的合并单元格：

```csharp
foreach (var mergedRangeAddress in _currentWorksheet.MergedCells)
{
    var mergedRange = _currentWorksheet.Cells[mergedRangeAddress];
    if (IsCellInRange(row, col, mergedRange))
    {
        // 获取合并区域的左上角单元格值
        var topLeftCell = _currentWorksheet.Cells[mergedRange.Start.Row, mergedRange.Start.Column];
        return topLeftCell.Value;
    }
}
```

### 2. 单元格值获取

修改了 `GetCellValueWithMergedCells` 方法，使其能够正确处理合并单元格：

- 首先检查当前单元格是否有值
- 如果为空，检查是否在合并区域内
- 如果在合并区域内，返回合并区域左上角单元格的值

### 3. 拆分逻辑

`SplitRowData` 方法现在专门处理合并单元格的拆分：

```csharp
private List<Dictionary<string, object>> SplitRowData(Dictionary<string, object> originalRow)
{
    // 获取原始行号
    var originalRowNumber = originalRow.ContainsKey("原始行号") ? originalRow["原始行号"] : 0;
    
    // 查找合并单元格并获取其范围
    var mergedCellRanges = GetMergedCellRangesForRow((int)originalRowNumber);
    
    // 创建一行，处理该行中的所有合并单元格
    var newRow = new Dictionary<string, object>();
    
    foreach (var kvp in originalRow)
    {
        var columnLetter = kvp.Key;
        var columnIndex = GetColumnIndexFromLetter(columnLetter);
        
        // 检查这个列是否在任何合并单元格范围内
        bool isInMergedRange = false;
        object mergedValue = null;
        
        foreach (var mergedRange in mergedCellRanges)
        {
            if (columnIndex >= mergedRange.Start.Column && columnIndex <= mergedRange.End.Column)
            {
                // 这是合并单元格范围内的列，使用合并单元格的值
                mergedValue = GetMergedCellValue(mergedRange);
                isInMergedRange = true;
                break;
            }
        }
        
        if (isInMergedRange)
        {
            newRow[columnLetter] = mergedValue;
        }
        else
        {
            // 这是合并单元格范围外的列，保持原始值
            newRow[columnLetter] = kvp.Value;
        }
    }
    
    return new List<Dictionary<string, object>> { newRow };
}
```

## 核心方法

### 1. GetCellValueWithMergedCells

```csharp
private object GetCellValueWithMergedCells(int row, int col)
{
    // 首先检查当前单元格是否有值
    var cell = _currentWorksheet.Cells[row, col];
    if (cell.Value != null)
    {
        return cell.Value;
    }

    // 如果当前单元格为空，检查是否在合并区域内
    foreach (var mergedRangeAddress in _currentWorksheet.MergedCells)
    {
        var mergedRange = _currentWorksheet.Cells[mergedRangeAddress];
        if (IsCellInRange(row, col, mergedRange))
        {
            // 获取合并区域的左上角单元格值
            var topLeftCell = _currentWorksheet.Cells[mergedRange.Start.Row, mergedRange.Start.Column];
            return topLeftCell.Value;
        }
    }

    return null;
}
```

### 2. GetMergedCellRangesForRow

```csharp
private List<OfficeOpenXml.ExcelRange> GetMergedCellRangesForRow(int row)
{
    var mergedRanges = new List<OfficeOpenXml.ExcelRange>();
    
    foreach (var mergedRangeAddress in _currentWorksheet.MergedCells)
    {
        var mergedRange = _currentWorksheet.Cells[mergedRangeAddress];
        if (row >= mergedRange.Start.Row && row <= mergedRange.End.Row)
        {
            mergedRanges.Add(mergedRange);
        }
    }
    
    return mergedRanges;
}
```

### 3. IsCellInRange

```csharp
private bool IsCellInRange(int row, int col, OfficeOpenXml.ExcelRange range)
{
    return row >= range.Start.Row && row <= range.End.Row &&
           col >= range.Start.Column && col <= range.End.Column;
}
```

### 4. GetColumnIndexFromLetter

```csharp
private int GetColumnIndexFromLetter(string columnLetter)
{
    int result = 0;
    for (int i = 0; i < columnLetter.Length; i++)
    {
        result = result * 26 + (columnLetter[i] - 'A' + 1);
    }
    return result;
}
```

## 使用场景

### 1. 合并单元格示例

假设Excel文件中有以下合并单元格：
- A1:A3 合并，值为 "部门A"
- B2:B4 合并，值为 "产品B"

### 2. 拆分前

```
行1: 部门A | 数据1 | 数据2
行2: 部门A | 产品B | 数据3
行3: 部门A | 产品B | 数据4
```

### 3. 拆分后

启用"拆分每一行"选项后，每个合并单元格会被拆分到对应的单元格：

```
行1: 部门A | 数据1 | 数据2
行2: 部门A | 产品B | 数据3
行3: 部门A | 产品B | 数据4
```

## 问题修复记录

### 问题描述
在初始实现中，出现了重复行的问题。比如第3行、第4行、第5行都重复显示了3次。

### 问题原因
原始的拆分逻辑是为每个合并单元格创建一行，这导致了重复行：
```csharp
// 错误的逻辑：为每个合并单元格创建一行
foreach (var mergedRange in mergedCellRanges)
{
    var newRow = new Dictionary<string, object>();
    // ... 处理逻辑
    splitRows.Add(newRow);
}
```

### 修复方案
修改为为每行创建一个新行，处理该行中的所有合并单元格：
```csharp
// 正确的逻辑：为每行创建一个新行，处理该行中的所有合并单元格
var newRow = new Dictionary<string, object>();

foreach (var kvp in originalRow)
{
    var columnLetter = kvp.Key;
    var columnIndex = GetColumnIndexFromLetter(columnLetter);
    
    // 检查这个列是否在任何合并单元格范围内
    bool isInMergedRange = false;
    object mergedValue = null;
    
    foreach (var mergedRange in mergedCellRanges)
    {
        if (columnIndex >= mergedRange.Start.Column && columnIndex <= mergedRange.End.Column)
        {
            mergedValue = GetMergedCellValue(mergedRange);
            isInMergedRange = true;
            break;
        }
    }
    
    if (isInMergedRange)
    {
        newRow[columnLetter] = mergedValue;
    }
    else
    {
        newRow[columnLetter] = kvp.Value;
    }
}

return new List<Dictionary<string, object>> { newRow };
```

## 调试功能

添加了详细的调试信息输出：

```csharp
System.Diagnostics.Debug.WriteLine("=== 开始拆分合并单元格 ===");
System.Diagnostics.Debug.WriteLine($"原始行数据: {string.Join(", ", originalRow.Select(kvp => $"{kvp.Key}={kvp.Value}"))}");
System.Diagnostics.Debug.WriteLine($"发现 {mergedCellRanges.Count} 个合并单元格");
```

## 测试方法

1. **准备测试数据**：创建包含合并单元格的Excel文件
2. **启用拆分功能**：勾选"拆分每一行"选项
3. **执行数据预览**：点击"数据预览"按钮
4. **验证结果**：检查合并单元格是否被正确拆分，且没有重复行

## 技术特点

1. **精确识别**：准确识别Excel中的合并单元格
2. **值继承**：合并单元格内的所有单元格都继承左上角的值
3. **范围处理**：正确处理跨行跨列的合并单元格
4. **调试友好**：提供详细的调试信息
5. **性能优化**：高效的合并单元格检测算法
6. **无重复行**：修复了重复行的问题，确保每行只显示一次

## 注意事项

1. **EPPlus版本**：确保使用兼容的EPPlus版本
2. **文件格式**：支持.xlsx和.xls格式
3. **内存使用**：大文件处理时注意内存使用
4. **错误处理**：包含完善的异常处理机制
5. **重复行问题**：已修复，确保不会出现重复行

## 总结

这个实现完全符合用户的需求，将合并单元格的内容拆分显示在每个单独的单元格中，而不是处理分隔符。功能已经实现并修复了重复行的问题，可以通过数据预览功能进行测试。 